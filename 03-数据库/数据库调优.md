

# 索引原理

## 索引

### 分页存储

​	单个数据页16K

### B+树结构



## 聚簇索引

​	主键的B+树，叶子节点包含完成的数据，非叶子节点对应主键信息排序

## 二级索引（单独指定的索引）

​	为减少磁盘占用，叶子节点仅给出对应主键索引的位置信息

### 回表

​	二级索引本身数据不完整，需要根据叶子节点上的主键信息，查询得到完整的信息

### 联合索引

​	非叶子节点按照联合索引定义，保存多个字段



# 创索引

## 原则



## 反面案例



# EXPLAIN



# 慢SQL优化

## 1. 无索引、索引失效导致慢查询

  错误：千万级数据表以一个没有索引的列作为查询条件



## 2、锁等待（表锁）

常见的存储引擎：InnoDB（支持行锁和表锁）和MyISAM（仅支持表锁）

错误实现：如果数据库操作是基于表锁实现的，比如一张订单表在更新时，需要锁住这个表，那么其他的查询等DB操作将处于阻塞状态。

推荐：InnoDB支持的行锁更适合高并发场景。

**但使用InnoDB时，需注意行锁升级为表锁的可能（批量更新时，行锁可能升级为表锁）**

- mysql认为如果对一行表使用大量行锁，会导致事务执行效率下降，从而可能造成其他事务长时间锁等待和更多的锁冲突问题发生，导致性能严重下降，从而将行锁升级为表锁。
- 行锁是基于索引加的锁，如果更新操作时，条件索引失效，那么行锁也会升级为表锁。

虽然行锁粒度更新，但可能带来新的问题：死锁。

## 3、不恰当的SQL

​	例如：习惯使用 select *、select count( * ) 语句，在大数据表中使用limit分页，以及对非索引字段进行排序等。











