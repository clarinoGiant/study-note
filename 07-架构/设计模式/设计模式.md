# 参考：

​	极客时间《设计模式之美》梳理而成。更多使用案例：参考博客园总结

# 一、设计模式学习导读

### 1.1 P02 如何评价代码好坏

代码评价标准：可维护性、可读性（符合编码规范）、可扩展性（开闭原则）、灵活性、简洁性（KISS原则）、可复用性、可测试性；



实现方式：

- 通过继承、多态写出可复用代码
- 编程规范：可读性好代码
- 设计模式、基于接口而非实现、里氏替换原则等，实现可复用、灵活、可读性好、易扩展、易维度代码
- 持续重构提升可维护性



### 1.2 P03: 面向对象、设计原则、设计模式、编程规范关系

**设计原则**

- SOLID
- DRY: Don't repeat yourself
- KISS:  Keep it Simple，Stupid
- YANGI:
- LOD

**面向对象、设计原则、设计模式、编程规范、代码重构、都是保持和提高质量的方法论。**

- 面向对象编程：具有丰富的特性（封装、抽象、继承、多态），可实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础；
- 设计原则：指导代码设计的一些经验总结，对某些场景下是否应应用某种设计模式，具有指导意义。如开闭原则是很多设计模式（策略、模板）的指导原则；
- 设计模式：针对软件开发中常遇到的设计问题，总结的一套解决方案。目的是提高代码的可扩展性。
- 重构：作为保持代码质量不下降的有效手段，利用面向对象、设计原则、设计模式、编码规范实现。

> 保证重构不出错的技术手段：单元测试和代码的可测试性

编写高质量代码：

- 面向对象

  - 封装、抽象、继承、多态
  - 基于接口而非实现编程
  - 多用组合少用继承
  - 贫血模型和充血模型

- 设计模式

  - 创建型

    - 常用：单例、工厂、建造者模式
    - 不常用：原型

  - 结构型：

    - 常用：代理、桥接、装饰者、适配器
    - 不常用：门面、组合、享元

  - 行为型：

    - 常用：观察者、模板、策略、职责链、迭代器、状态

    - 不常用：访问者、备忘录、命令、解释器、中介
  
  
  
 # 二、设计原则与思想

 ## 2.1 面向对象

 ### P07 哪些代码设计看似面向对象，实际面向过程

  ``` java
  public class ShoppingCart {
      private int itemsCount;
      private double totalPrice;
      private List<ShoppingCartItem> items = new ArrayList<>();
      
      public void addItem(ShoppingCartItem item) {
          items.add(item);
          itemsCount++;
          totalPrice += item.getPrice();
      }
      
      public List<ShoppingCartItem> getItems() {
          return Collections.unmodifiableList(this.item);  // 确保外部不可修改该list，但仍可获取单个item修改其字段内容
      }
  }
  ```

  - 滥用getter、setter

         默认使用lombok生成所有属性的get和set方法，使得不应外部访问的属性被外部错误修改

         错误样例：

         1、totalPrice 和 itemsCount 对外开放set方法，导致外部可以随意修改取值；

         2、对外开放getItems方法，外部可以先获取items后执行clear方法； 

  - 滥用全局变量和全局方法

    应该拆分xxxConstants和Utils类，按照具体业务场景细分成小的类；全局的大类会导致已来访编译时间长。

  - 定义数据和方法分离的类，即贫血模型



### P08 接口和抽象类区别

	接口：侧重于解耦； 抽象类：更多为了代码复用

   ``` java
   public Abstract class Logger {
       private String name;
       private boolean enabled;
       private Level minPermittedLevel;
       
       public Logger(String name, boolean enabled, Level minPermittedLevel) {
           ...
       }
       
       public void log(Level level, String message) {
           boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intLevel())
           if (!loggable) return;;
           doLog(level, message);
       }
       
       public abstract void doLog(Level level, String message);
   }
   
   public class FileLogger extends Logger {
       private Writer fileWriter;
       
       public FileLogger(String name; boolean enabled, Level minPermittedLevel, Strin filePath) {
       	super(name, enabled, minPermittedLevel);
           this.fileWrite = new FileWriter(filePath);
       }
       
       @Override
       public void doLog(Level level, String message) {      
           // 格式化level和message
           fileWriter.write(...);
       }
   }
   ```

接口使用场景

``` java
public interface Filter {
    void doFilter(RpcRequest req) throws RpcException;
}

public class AuthencationFilter implements Filter {
    @Override
    public void doFilter(RpcRequest req) throws RpcException {
        ....
    }
}

public class RateLimitFilter implements Filter {
    @Override 
    public void doFilter(RpcRequest req) throws RpcException {
        ...
    }
}

public class Application {
    private List<Filter> filters = new ArrayList<>();
    //  filters.add(new AuthencationFilter())
    //  filters.add(new RateLimitFilter())
    
    public void handleRpcRequest(RpcRequest req) {
	    try {
    	    for (Filter filter : filters) {
	            filter.doFilte(req)
    	    }
	    } catch (RpcException e) {
    	    处理过滤结果
	    }
        ....
	}
}

```



### P09 基于接口而非实现编程

将接口和实现分离，封装不稳定实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节。从而当实现变化的时候，上游系统代码基本不需要做改动，降低代码间的耦合性，提到代码的扩展性。

根据实际需要定义接口，不要过度设计。

``` java
public interface ImageStore {
    String upload(Image image, String bucketName);
    Image download(String url);
}

public Class AliyunImageStore implements ImageStore {
    ...
}

public class PrivateImageStore implements ImageStore {
    ....
}

使用方
ImageStore imageStore = new PrivateImageStore();
imageStore.upload(image, BUCKET_NAME)
```



### P10 多用组合少用继承



``` java
public interface Flyable { void fly(); }
public interface Tweetable { void tweet(); }
public interface EggLayable { void layEgg(); }

public class TuoNiao implements Tweetable, EggLayable {
    ...
    @Override
    public void tweet() { ///}
    @Override
    public void layEgg() { ///}
}
public class MaQue implemnts Flyable, Tweetable, EggLayable {
    @Override
    public void fly() { ///}
    @Override
    public void tweet() { ///}        
    @Override
    public void layEgg() { ///}
}
```

// 上述存在的问题，鸵鸟和麻雀都需要实现layEgg方法，且实现逻辑一样，造成代码重复。

优化方式：组合

``` java
public interface Flyable {
    volid fly()
}
public class FlyAblility implemnts Flyable {
    @Override
    public void fly() { ....}
    }
}
// 省略 Tweetable/TweetAbility/EggLayable/EggLayAbility
public class TuoNiao implements Tweetable, EggLaybalbe {
    private TweetAbility tweetAbility  = new TweetAbility();
    private EggLayAbility eggLayAbility  = new EggLayAbility();
    @Override
    public void tweet() { tweetAbility.tweet(); }  // 委托
    @Override
    public void layEgg() { eggLayAbility.layEgg(); } // 委托
}
```

继承改写成组合意味着更细粒度类的拆分 -》 需要定义更多的类和接口，会造成代码复杂度和维护成本。

- 如果系统不稳定，继承层次很深，继承关系复杂，尽量使用组合代替继承。

- 如果类之间结构稳定，继承层次比较浅（如最多有两层继承关系），继承关系不复杂，就可以大胆使用继承；

组合：装饰者、策略、组合

### P11 充血模型

- Controller层：负责接口的暴露；
- Service类：负责与Repository交互，转换成领域模型，然后由领域模型完成业务逻辑；最后调用Repository方法，将数据持久化。
- Repository：负责与数据库打交道



### P13-14 接口鉴权设计

#### 类之间关系（聚合、组合、管理、依赖等）

1、聚合：A包含B对象，B生命周期可不依赖A的生命周期，如学生与课程关系

   ``` java
   public class A {
       private B b;
       public A(B b) {
           this.b = b;
       }
   }
   ```

2、组合：同生共死

``` java
public class A {
    private B b;
    public A() {
        this.b = new B();
    }
}
```

3、关联：非常弱的关系，包含聚合和组合两种关系；如果B是A的成员变量，则B与A就是关联关系

4、依赖：比关联更弱的关系，包含关联关系；不管B作为A成员变量、方法参数、返回值、局部变量，只要B与A有任何使用关系，都称为有依赖关系。



#### 模拟需求

**校验过程**

- 调用方接口请求时，讲URL,AppID,密码,时间戳拼接在一起，通过加密算法生成token，并将token、AppID、时间戳拼接在URL中，一并发送到微服务端；
- 微服务端接收调用方接口请求后，从请求中拆解出token、AppID和时间戳；
- 微服务端首先检查传递过来的时间戳跟当前时间，是否在token失效时间内。如果已超期，判定鉴权失败，拒绝请求；
- 如果token未过期失效，微服务端从自己的存储中，取出AppID对应的密码，通过同样的token生产算法，生成另一个token，与调用方传递的token匹配；如一致则鉴权成功，否则拒绝接口调用。

**代码实现**

划分职责识别有哪些类 -》定义类及属性和方法-》定义类与类之间交互关系-》将类组装起来并提供执行入口

定义几个类

``` java
class AuthToken {
    private static final long DEFAULT_EXPIRED_TIMED_INTERVAL = 1*60*1000;
    private String token;
    private long createTime;
    private expiredTimeInterval = DEFAULT_EXPIRED_TIMED_INTERVAL;
    
    public AuthToken(String token, long createTime);
    public AuthToken(String token, long createTime, long expiredTimeInterval);
    
    public static AuthToken create(String baseUrl, long createTime, Map<String, String> params);
    // 根据业务模型，识别应该具有哪些属性和方法
    public String getToken();
    public boolean isExpired();
    public boolean match(AuthToken authToken);
}

class ApiRequest {
    private String baseUrl;
    private String token;
    private String appId;
    private long timeStamp;
    
    public ApiRequest(String baseUrl, String token, String AppId, long timeStamp);
    
    public static ApiRequest createFromFullUrl(String url);
    public String getBaseUrl();
    public String getToken();
    public String getAppId();
    public long getTimeStamp();
}
```

为了做到抽象封装具体的存储方式，基于接口而非具体的实现编程。

``` java
interface ApiAuthenticator {
    void auth(String url);
    void auth(ApiRequest apiRequest);
}

public class DefaultApiAuthenticatorImpl implements ApiAuthenticator {
    private CredenticalStorage credenticalStorage;
    
    public DefaultApiAuthenticatorImpl();
    public DefaultApiAuthenticatorImpl(CredenticalStorage credentialStorage);
    
    public void auth(String url);
    public auth(ApiRequest apiRequest);
}
```

#### 辩证思考与灵活应用

设计阶段不可能把每个细节都分析清楚，在落实代码时要反复迭代、重构、打破重写。

## 2.2 设计原则

### P15 单一职责原则SRP

通常先写一个粗粒度类满足业务需求，根据业务需要再拆分成细粒度的类，持续重构

样例：

```java
public class UserInfo {
    private Long userId;
    private String userName;
    private String email;
    private String telphone;
    private long createTime;
    private long lastLoginTime;
    private String proviceOfAddress;
    private String cityOfAddress;
    private String regionOfAddress;
    private String detailOfAddress;
    ....
}
```

针对地址是否要提取独立类，根据实际业务情况分析；假如地址与其他信息只是用来展示，当前设计没问题；

- 如果产品其他模块也会出现用户的地址信息，则地址信息，应该拆分成独立的用户物流信息（地址信息类）
- 如果后续用户一个账号在公司所有产品登录，则需要将身份认证的信息提取独立类。

### P16 开闭原则

针对API的告警规则样例

设计模式：装饰、策略、模板、职责链、状态

修改前：如果要新增一个校验参数比如timeCount，则需要check入参和实现都要修改

``` java
public class Alert {
    private AlertRule rule;
    private Notification notification;
    
    public Alert(AlertRule rule, Notificatioin notification) {
        this.rule = rule;
        this.notificatioin = notification;
    }
    
    public void check(String api, long requestCount, long errorCount, long durationSeconds)
    {
        // 根据不同的规则对入参做校验
    }   
}
```

改造后

```java
public class Alert {
    private List<AlertHandler> alertHandlers = new ArrayList<>();
    
    public void addAlertHandler(AlertHandler alertHandler) {
        this.alertHandlers.add(alertHandler);
    }
    
    public void check(ApiStatInfo apiStatInfo) {
        for(AlertHandler handler : alertHandlers) {
            handler.check(apiStatInfo);
        }
    }
}

public class ApiStatInfo {  // constructor/getter/setter
    private String api;
    private long requestCount;
    private long errorCount;
    private long durationSeconds;
}

public abstract class AlertHandler {
    protected AlertRule rule;
    protected Notification notification;
    public AlertHandler(AlertRule rule, Notification notification) {
        this.rule = rule;
        this.notification = notification;
    }
    public abstract class check(ApiStatInfo apiStatInfo);
}
        
// 具体的AlertHandler
public class TpsAlertHandler extends AlertHandler {
    public TpsAlertHandler(AlertRulte rule,  Notification notification) {
        super(rule, notification);
    }
    
    @Override
    public void check(ApiStatInfo apiStatInfo) {
        ....
    }
}
// 其他具体handler定义
```

单例类ApplicationContext

```java
public class ApplicationContext {
    private AlertRule alertRule;
    private Notification notification;
    private Alert alert;
    
    public void initalizeBeans() {
        alertRule = new AwN9fQwN9fQ8mZlertRule(xxxx);
        notification = new Notification(....);
        alert = new Alert();
        alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
        alert.addAlertHandler(new xxxAlertHandler(...));
    }
    
    public Alert getAlert() {returen alert;}
   
    // 内部静态类方式单例实现
    private static final ApplicationContext instance = new ApplicationContext();
    private ApplicationContext() {
        initializeBeans();        
    }
    
    public static ApplicationContext getInstance() {
        return instance;
    }        
}

public class Demo {
    public static void main(String[] args){
        ApiStatInfo apiStatInfo = new ApiStatInfo();
        // 设置apiStatInfo具体属性
        ApplicationContext.getInstance().getAlert().check(apiStatInfo);
    }
}
```

### P17 里氏代换原则LSP

违反LSP原则的例子，可通过父类的单元测试去验证子类的实现。

- 子类违背父类声明要实现的功能

  如：父类进行金额升序排序，但是子类按照日期排序

- 子类违背父类对输入、输出和异常的约定

  如：父类约定出错返回null，但子类返回空集合；父类只允许输入任意整数，子类仅支持正整数

- 子类违背父类所罗列的任何特殊说明

  

### P18 接口隔离原则 ISP

Client should not be forced to depend upon interface that they do not use. 客户端（调用方）不应被强迫依赖它不需要的接口；

场景一：

微服务提供了UserService的接口：注册、登录、获取用户信息等；当前后台需实现删除用户功能，希望后台提供删除用户功能。

常规操作：因希望删除动作仅开放给后台系统使用，如果直接在UserService提供一个delete接口，所有使用UserService系统都可以删除；

正常在删除前会对接口鉴权，但是在没鉴权框架支撑前，可新建一个单独的RestrictedUserService实现删除功能，由后台调用。



场景2：接口理解为单个API

每个API定义的职责单一，比如统计类中max、min、avg等不同的接口



### P19  KISS & YANGI

KISS:  keep it simple，stupid

YANGI: You aren't gonna need it.  不要设计当前用不到的功能。



### P21 DRY 复用性

DRY： Don't Repeat Yourself

- 实现逻辑重复

  用户校验类，即便是否有效用户和密码可能完全重复实现，但应各自定义单独的方法，将重复的内部校验实现提取成公共的方法。

- 功能语义重复

  错误实现：同一个类下 isValidIp 和 checkIfIpValid 方法 同时存在

- 代码执行重复

  错误案例：

  ```java
  class UserService {
      private UserRepo userRepo;
      public User login(String email, String password) {
          boolean existed = userRepo.checkIfUserExisted(email, password);
          if(!existed) { 抛出认证失败异常}
          User user = userRepo.getUserByEmail(email);
          return user;
      }
  }
  
  // 如果UserRepo的上述check和get方法存在重复的实现逻辑，比如都执行了EmailValidation.validate(email)，则会造成重复的数据库IO操作，应避免
  ```
  
  
  
  如何提高代码复用性
  
  1. 减少代码耦合；
  2. 满足单一职责原则
  3. 模块化
  4. 业务和非业务逻辑分离
  5. 通用代码下沉
  6. 继承、多台、抽象、封装
  7. 应用模板等设计模式
  
  
  
  ### P22 迪米特LOD 高内聚低耦合
  
  高内聚：相近的功能放到同一类
  
  低耦合：依赖注入、接口隔离、基于接口而非实现编程
  
  
  
  样例：确保每个只依赖有限接口；如果序列化和反序列化各自定义独立class，那么修改的时候要修改两处，不够高内聚。
  
  ```java
  public interface Serializable {
      String serialize(Object object);
  }
  public interface Deserizalizable {
      Object deserialize(String text);
  }
  
  public class Serialization implements Serializable,Deserizalizable{...}
  
  public class DemoClass_1 {
      private Serializable serializer;
      public DemoClass_1(Serializable serializer)
  }
  
  public class DemoClass_1 {
      private Deserizalizable deserializer;
      public DemoClass_1(Deserizalizable serializer)
  }
  ```
  
  
  
### P25 一个案例分析和实现

  参考原始文档
    

## 2.3 规范与重构

### P27 重构什么？

  1、大规模重构

       顶层代码设计的重构，包括系统、模块、代码结构、类与类之间的关系等的重构；
    
       手段：分层、模块化、解耦、抽象可复用组件等，涉及到设计思想、原则和模式的掌握

  2、小规模重构

       代码细节的重构，针对类、函数、变量等代码级别的重构，如命名、注释、消除超大类或函数、重复代码消除等，更多依赖编程规范

### P31 快速改善代码质量的方法

1、利用上下文简化命名

2、将代码分割成更小的单元块

3、避免参数过多：1）考虑是否职责单一；2）将函数参数封装成对象；

4、不要用函数参数来控制逻辑

5、函数设计要职责单一

	public boolean checkUserIfExistingByTelephone(String telphone)
	
	public boolean checkUserIfExistingByUserName(String username)
	
	public boolean checkUserIfExistingByEmail(String email)

6、移除过深的嵌套层次

	1）卫语句提前返回；2）封装函数调用，减少嵌套；3）使用continue、break等提前退出嵌套；

7、引入解释性变量，如SUMMER_START,SUMMER_END

###  P34 如何发现代码质量问题

1、常规checklist

- 目录是否设置合理、模块划分是否清晰、代码是否满足高内聚、低耦合
- 是否遵循经典设计原则和设计思想 SOLID/DRY/KISS/YAGNI/LOD等
- 设计模式是否应用得当，是否有过度设计
- 代码是否容易扩展？如果要添加新功能，是否容易实现
- 代码是否可以复用？是否可以复用已有的项目代码或类库
- 代码是否容易测试？单元测试是否覆盖各种正常和异常的情况
- 代码是否易读？是否符合编程规范（命名、注释、代码风格一致）

2、业务需求checklist

	- 代码是否实现预期的业务需求
	- 逻辑是否正确？是否处理了各种异常情况
	- 日志打印是否得当？是否方便debug排查问题
	- 接口是否易用？是否支持幂等、事务等？
	- 是否存在并发问题？是否线程安全？
	- 性能是否有优化空间？比如SQL/算法等是否可优化？
	- 是否有安全漏洞？比如输入输出是否校验全面？

###  P36 程序出错应该如何返回

场景 func2实现调用func1

1、如果func1抛出的异常可恢复，且func2调用方不关心此异常，完全可以在func2将func1抛出的异常吞掉（只记录error日志）；

2、如果func1抛出异常对func2是可以理解和关心的，且业务上存在一定关联性，可以直接将func1异常直接抛出

3、如果func1异常太底层，且func2调用方缺乏背景去理解，且业务概念上无关，可以包装成调用方可理解新异常，然后re-throw

###  P37 异常处理案例

```java
public class RandomIdGenerator implements IdGenerator {
    private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);
    
    @override
    public String generate() throws IdGenerationFailureException {
        String substrOfHostName = null;
        
        try {
            substrOfHostName = getLastFieldOfHostName();
        } catch(UnknownHostException e) {
            // 不能直接对外抛出unknownhost异常，暴露了内部的实现
            throw new IdGenerationFailureException("...", e);
        }
        
        long currentTimeMillis = System.currentTimeMillis();
        String randomString = generateRandomAlphametric(8);
        String id = String.format("%s-%d-%s",
                                 substrOfHostName, currentTimeMillis, randomString);
        return id;
    }
    
    private String getLastFieldOfHostName() throws UnknownHostException {
        String substrOfHostName = null;
        String hostName = InetAddress.getLocalHost().getHostName();
        if(hostName == null || hostName.isEmpty()) {
            throw new UnknownHostException("...");
        }
        substrOfHostName = getLastSubstrSplitterByDot(hostName);
        return substrOfHostName;
    }
}
```



# 三、设计模式与范式

## 3.1 创建型

### 	P43 单&多例模式（进程和集群单例）

   1、如何实现线程唯一的单例

```java
public class IdGenerator {
    private AtomicLong id = new AtomLong(0);
    
    private static final ConcurrentHashMap<long, IdGenerator> instances = new ConcurrentHashMap<>;
    
    private IdGenerator() {}
    
    public static IdGenerator getInstance() {
        long currentThreadId = Thread.currentThread().getId();
        instances.putIfAbsent(currentThread, new IdGenerator());
        return instances.get(currentThreadId);
    }
    
    publid long getId() {
        return id.incrementAndGet();
    }
}
```

	2、如何实现集群环境下单例

> 经典单例模式是进程内唯一。如何实现集群唯一？ 将单例对象序列化并存储到外部共享区如文件。进程使用时，先加载到内存并反序列化成对象并使用。
>
> 为保证任何时刻进程内只有一个实例，一个进程获取到对象后，需对对象加锁。使用完后需要显式将对象从内存中删除，并释放对象的加锁。

伪码实现

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLOng(0);
    private static IdGenerator instance;
    private static SharedObjectStorage storage = FileSharedObjectStorage(如文件地址的入参);
    private static DistributedLock lock = new DistributedLock();
    
    private IdGenerator() {}
    
    // 从持久化文件加载
    public synchronized static IdGenerator getInstance() {
        if (instance == null) {
            lock.lock();
            instance = storage.load(IdGenerator.class);
        }            
        return instance;
    }
    
    // 重新持久化
    public synchonized void freeInstance() {
        storage.save(this, IdGenerator.class);
        instance = null; // 释放对象
        lock.unlock();
    }
    
    public long getId() { return id.incrementAndGet();}
}

IdGenerator idGenerator = IdGenerator.getInstance();
long id = idGenerator.getId();
idGenerator.freeInstance();
```

3、如何实现多例模式

使用场景？

```java
public class BackendServer {
    private long serviceNo;
    private String serverAddress;
    
    private static final int SERVER_COUNT = 3;
    private static final Map<Long, BackendServer> serverInstances = new HashMap();
    
    static {
        serverInstances.put(1L, new BackendServer(1L, "192.134.22.138:8080"));
        serverInstances.put(2L, new BackendServer(2L, "192.134.22.138:8080"));
        serverInstances.put(3L, new BackendServer(3L, "192.134.22.138:8080"));
    }
    
    private BackendServer(long serverNo, String serverAddress) {
        this.serverNo = serviceNo;
        this.serverAddress = serverAddress;
    }
     
    public BackendServer getInstance(long serverNo) {
        return serverInstances.get(serverNo)；
    }
    
    public BackendServer getRandomInstance() {
        Random r = new Random();
        int no = r.nextInt(SERVER_COUNT) + 1;
        return serverInstances.get(no)；
    }
}
```



###  3.2 P44&P45 工厂模式

#### 简单工厂

```java
public class RuleConfigFactory {
    private static final Map<String, RuleConfigParser>  cachedParsers = new HashMap<>();
    
    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
    }
    
    public staitc IRuleConfigParser createParser(String configFormat) {
        if(configFormat == null || configFormat.isEmpty()) {
            return null;
        }
        
        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
        returen parser;
    }
}
```



#### 工厂方法



#### 抽象工厂

一个工厂负责创建多个不同类型的对象

```java
public interface IConfigParserFactory {
    IRuleConfigParser createRuleParser();
    ISystemConfigParser createSystemParser();
}

public class JsonConfigParserFactory implements IConfigParserFactory {
    @override
    public IRuleConfigParser createRuleParser() {
        return new JsonRuleConfigParser();
    }
    
    @override
    public ISystemConfigParser createSystemParser() {
        return new JsonSystemConfigParser();
    }
}

// 其他类型，如XML格式
```



#### 如何判别使用简单工厂还是工厂方法

如果对象创建比较简单，使用简单工厂

如果某个代码块逻辑负责，剥离后可使代码更清晰、可读和可维护 -- 使用工厂方法

## 

## 3.2 结构型

###  代理、适配器、桥接、装饰器区别

装饰器：装饰器类与原始类继承同样的父类，是对功能的增强，如java的文件流

代理模式：代理类附加的是原始类无关的功能

适配器：将不兼容的接口转换成可兼容的接口。日志框架；1）封装有缺陷的接口设计；2）统一多个类的接口设计；3）替换依赖的外部系统；4）兼容老版本接口

桥接模式：将接口部分和实现部分分离，从而可以相对独立的改变。



### 享元模式

典型使用场景：Java Integer、String

游戏场景：每个房间的棋局要保存每个棋子的数据（棋子类型，颜色，位置）；为避免创建重复的棋子类型和颜色

改造：将所有棋子通过享元类保存，

```java
// 享元类
public class ChessPieceUnit {
    private int id;
    private String text;
    private Color color;
    
    public ChessPieceUnit(int id, String text, Color color) {
        this.id = id;
        this.text = text;
        this.color = color;
    }
    
    public static enum Color {
        RED,BLACK
    }
    // 其他属性和getter方法
}

public class ChessPieceUnitFactory {
    private static final Map<Integer, ChessPieceUnit> pieces = new HashMap<>();
    
    static {
        pieces.put(1, new ChessPiectUnit(1, "车", ChessPieceUnit.Color.BLACK));
        pieces.put(2, new ChessPiectUnit(1, "马", ChessPieceUnit.Color.BLACK));
        // ....
    }
    
    public static ChessPieceUnit getChessPiece(int chessPieceId) {
        return pieces.get(chessPieceId);
    }    
}

public class ChessPiece {
    private ChessPieceUnit chessPieceUnit;
    private int positionX;
    private int positionY;
    
    public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) {
        this.xxx = xxxx
    }
    // getter、setter
}

public class ChessBoard {
    private Map<Integer, ChessPiece>  chessPieces = new HashMap<>();
    
    public ChessBoard() {
        init();
    }
    
    private void init() {
        chessPieces.put(1, new ChessPiece(ChessPieceUnitFactory.getChessPiece(1), 0, 0));
        chessPieces.put(2, new ChessPiece(ChessPieceUnitFactory.getChessPiece(2), 1, 0));
        // ...
    }
    
    public void move(int chessPieceId, int toPositionX, int toPositionY) {
        // ...
    }    
}
```

## 3.2 行为型

### 观察者模式

典型案例：google Guava EventBus

场景：P2P理财系统，当 用户注册成功后，需执行一系列动作和通知，可以使用观察者模式

```java
public interface Observer {
    void handle(long userId);
}

public class ObserverA implements Observer {
    @override
    void handle(long userId) {xxx}
}
public class ObserverB implements Observer {
    @override
    void handle(long userId) {xxx}
}

public class UserController {
    private UserService userService;
    private List<Observer> regObservers = new ArrayList<>();
    
    public void setRegObservers(List<Observer> observers) {
        regObservers.addAll(observers);
    }
    
    public long register(String telephone, String password) {
        long userId = userServer.register(telephone, password);
        // 遍历执行所有的观察者handler方法
    }
}
```

如果想实现异步的处理，可以Controller定义一个Executor线程池，每次都是提交到线程池中执行。



### 模板模式

模板作用1: 复用，案例JDK中AbstractList

模板作用2：扩展，案例 servlet



### 策略模式

典型实现

```java
public interface Strategy {
    void handle();
}
public class ConcreteStrategyA implements Strategy {
    ///
}
public class ConcreteStrategyB implements Strategy {
    ///
}
// 简单工厂
public class StrateyFactory {
    private static final Map<String, Strategy> strategies = new HashMap<>();
    
    static {
        strategies.put("A", new ConcreteStrategyA());
        strategies.put("B", new ConcreteStrategyB());
    }
    
    public static Strategy getStrategy(String type) {
        if (type == null || type.isEmpty())  return 非法参数异常;
        return strategies.get(type);           
    }
}
```

利用策略避免if-else: 将每个if分支代码成一个具体策略的实现

### 职责链

职责链变种，没有设置successor，而是通过返回是否成功，由调用方来决定是否要继续执行下一职责链

典型使用：Servlet的 Filter，Spring MVC 的拦截器

场景：针对一段文本的敏感词处理

```java
public interface SensitiveWordFilter {
    boolean doFilter(Content content);
}

public class SexyWordFilter implements SensitiveWordFilter {
    @override
    public boolean doFilter(Content content) {
        bolean legal = true;
        // xxx
        returen legal;
    }
}
// 定义其他类型的Filter，有的过滤器如果遇到指定敏感词对应内容返回false

public class SensitiveWordFilterChain {
    private List<SensitiveWordFilter> filters = new ArrayList<>();
    
    public void addFilter(SensitiveWordFilter filter) {
        this.filters.add(filter);
    }
    
    public boolean filter(Content content) {
        for (SensitiveWordFilter filter : filters) {
            if (!filter.doFilter(content)) {
                return false;
            }
        }
        return true;
    }
}

public class ApplicationDemo {
    public static void main(String[] args) {
        SensitiveWordFilterChain filterChain = new SensitiveWordFilterChain();
        filterChain.addFilter(new AdsWordFilter);
        filterChain.addFilter(new PoliticalWordFilter);
        filterChain.addFilter(new SexyWordFilter);
        
        bolean legal = filterChain.filter(new Content());
        if (!legal)  不发表
        else 发表
        
    }
}     
```



















  

  

  

  